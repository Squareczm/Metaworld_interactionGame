# Integration Plan for `game_status.md` and GDD

This document outlines the strategy for integrating the existing Markdown-based game state (`game_status.md`) and Game Design Document (`GDD_Execution.md`) into the web application.

## A. `game_status.md` Management

1.  **Location:**
    *   The `game_status.md` file will be stored on the server within the project structure, accessible by the Flask backend application.
    *   An initial `game_status_template.md` might be created to facilitate new game initialization.

2.  **Reading:**
    *   Upon receiving a user interaction (e.g., via the `/api/chat` endpoint), the Flask backend will be responsible for reading the `game_status.md` file.
    *   A Python library for Markdown parsing (e.g., `Mistune`, `Markdown`) or custom regex-based parsing will be used to convert the structured Markdown content into an in-memory Python data structure (like a dictionary or a custom object). This structure will represent the current game state.

3.  **Updating:**
    *   The core game logic / AI GM (see section B) will determine changes to the game state based on user actions and GDD rules.
    *   The AI GM will output state changes in the structured "【状态更新指令块】" format specified in `Master_prompt.md`.
    *   The Flask backend will parse this "update block."
    *   The backend will then apply these changes to its in-memory representation of the game state.
    *   After updating the in-memory state, the backend will overwrite the entire `game_status.md` file with the new state, converting the Python data structure back into the defined Markdown format. This approach is simpler to implement robustly than in-place modification of the Markdown file.
    *   **Concurrency Note:** This initial plan assumes a single-player context. For multiple concurrent players, this file-based state management would need to be replaced with a database or a per-user state file system.

4.  **Initialization ("New Game"):**
    *   A "new game" function in the backend will be responsible for creating a fresh `game_status.md`.
    *   This could involve copying `game_status_template.md` and then populating initial player-specific details (name, chosen archetype attributes based on `GDD_Execution.md`).

## B. GDD and AI GM Logic Integration

1.  **GDD Access (`GDD_Execution.md`):**
    *   The `GDD_Execution.md` file will also reside on the server, accessible by the backend.
    *   The AI GM logic component will read and use information from the GDD (e.g., character progression, story branches, NPC details) to guide the narrative.

2.  **AI Game Master (GM) Implementation Strategy:**
    *   The Flask backend's `/api/chat` endpoint will orchestrate the game turn.
    *   It will call an internal module/function, for example, `process_turn(current_game_state, user_input, gdd_data)`.
    *   This `process_turn` function will be responsible for:
        *   Constructing a detailed prompt for a Large Language Model (LLM). This prompt will include:
            *   Relevant sections from `GDD_Execution.md` (e.g., current story arc, NPC behaviors).
            *   Key elements from `Master_prompt.md` and `project_rules.md` (to guide LLM behavior, response format, and request for state updates).
            *   The current game state (from the parsed `game_status.md`).
            *   The user's latest message/action.
        *   Sending this prompt to an LLM API.
        *   Receiving the LLM's response, which is expected to contain:
            *   The narrative text for the current turn.
            *   The "【状态更新指令块】" detailing changes to `game_status.md`.
        *   Parsing the narrative and the state update block from the LLM's response.
    *   The `/api/chat` endpoint will then take the parsed narrative and the proposed state changes to update `game_status.md` as per section A.3.

## C. Image Prompt Generation

1.  **Source:** The narrative text generated by the AI GM for the current turn will be the primary source for generating the image prompt.
2.  **Strategy:**
    *   **Simple:** Automatically use the last 1-2 sentences of the narrative text as the prompt for the image generation API.
    *   **Advanced (Future):** The AI GM could be designed to explicitly output a suggested image prompt within its response, separate from the main narrative, to allow for more tailored image generation.
3.  **Integration:** After the narrative is generated (and before sending the response to the frontend), the backend will form the image prompt and call the image generation API (currently the placeholder `generate_image_placeholder` function, eventually a real API).

## D. Overall Backend Workflow for a Game Turn (`/api/chat`)

1.  User submits input through the frontend.
2.  Flask backend's `/api/chat` endpoint is triggered:
    a.  Load current game state by reading and parsing `game_status.md`.
    b.  Call the internal `process_turn` function (which encapsulates AI GM logic and LLM interaction, using GDD content).
    c.  `process_turn` returns the narrative for the turn and the proposed state update block.
    d.  Apply the state updates to the in-memory game state.
    e.  Overwrite `game_status.md` with the new game state.
    f.  Generate an image prompt from the received narrative.
    g.  Call the image generation API (e.g., `generate_image_placeholder` or a real one) with this prompt to get an image URL.
    h.  Construct a JSON response containing the narrative text and the image URL.
3.  Send this JSON response back to the frontend.
4.  Frontend updates the UI to display the new narrative and image.

This plan provides a roadmap for integrating the complex text-based game logic into the web application framework.
